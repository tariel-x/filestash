// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: noise.proto

package pb

import (
	fmt "fmt"
	math "math"
	time "time"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// NoiseProtocol represents the handshake pattern and cipher suite.
type NoiseProtocol int32

const (
	NoiseProtocol_NOISE_UNSET                       NoiseProtocol = 0
	NoiseProtocol_NOISE_IK_25519_CHACHAPOLY_BLAKE2B NoiseProtocol = 1
	NoiseProtocol_NOISE_IK_25519_AESGCM_BLAKE2B     NoiseProtocol = 2
)

var NoiseProtocol_name = map[int32]string{
	0: "NOISE_UNSET",
	1: "NOISE_IK_25519_CHACHAPOLY_BLAKE2B",
	2: "NOISE_IK_25519_AESGCM_BLAKE2B",
}

var NoiseProtocol_value = map[string]int32{
	"NOISE_UNSET":                       0,
	"NOISE_IK_25519_CHACHAPOLY_BLAKE2B": 1,
	"NOISE_IK_25519_AESGCM_BLAKE2B":     2,
}

func (x NoiseProtocol) String() string {
	return proto.EnumName(NoiseProtocol_name, int32(x))
}

func (NoiseProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_14d195bf72570c49, []int{0}
}

// NoiseInfo represents the information an initiator needs to connect over Noise
// to a specific peer.
type NoiseInfo struct {
	Proto                NoiseProtocol `protobuf:"varint,1,opt,name=proto,proto3,enum=noise.NoiseProtocol" json:"proto,omitempty"`
	PublicKey            []byte        `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *NoiseInfo) Reset()         { *m = NoiseInfo{} }
func (m *NoiseInfo) String() string { return proto.CompactTextString(m) }
func (*NoiseInfo) ProtoMessage()    {}
func (*NoiseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_14d195bf72570c49, []int{0}
}
func (m *NoiseInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoiseInfo.Unmarshal(m, b)
}
func (m *NoiseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoiseInfo.Marshal(b, m, deterministic)
}
func (m *NoiseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoiseInfo.Merge(m, src)
}
func (m *NoiseInfo) XXX_Size() int {
	return xxx_messageInfo_NoiseInfo.Size(m)
}
func (m *NoiseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_NoiseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_NoiseInfo proto.InternalMessageInfo

func (m *NoiseInfo) GetProto() NoiseProtocol {
	if m != nil {
		return m.Proto
	}
	return NoiseProtocol_NOISE_UNSET
}

func (m *NoiseInfo) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

// NoiseKeyAttestation is a structure that shows the given Noise public key
// belongs to a specific node id. The Noise public key (and signing timestamp)
// are signed by the leaf key of the node's cert chain, where the node's cert
// chain is validated to belong to the given node id.
// Note that a NoiseSessionAttestation is preferred to a NoiseKeyAttestation
// if possible, and required if you are interested in channel binding.
// NoiseKeyAttestation, on the other hand, doubles as a more secure form of
// NoiseInfo.
type NoiseKeyAttestation struct {
	NodeCertchain []byte        `protobuf:"bytes,2,opt,name=node_certchain,json=nodeCertchain,proto3" json:"node_certchain,omitempty"`
	NoiseProto    NoiseProtocol `protobuf:"varint,3,opt,name=noise_proto,json=noiseProto,proto3,enum=noise.NoiseProtocol" json:"noise_proto,omitempty"`
	// these two values are part of the signature.
	NoisePublicKey []byte    `protobuf:"bytes,4,opt,name=noise_public_key,json=noisePublicKey,proto3" json:"noise_public_key,omitempty"`
	Timestamp      time.Time `protobuf:"bytes,5,opt,name=timestamp,proto3,stdtime" json:"timestamp"`
	Signature      []byte    `protobuf:"bytes,6,opt,name=signature,proto3" json:"signature,omitempty"`
	// signers should fill this in, validators should ignore this field
	// and just use the node id computed by the cert chain.
	DeprecatedNodeId     NodeID   `protobuf:"bytes,1,opt,name=deprecated_node_id,json=deprecatedNodeId,proto3,customtype=NodeID" json:"deprecated_node_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoiseKeyAttestation) Reset()         { *m = NoiseKeyAttestation{} }
func (m *NoiseKeyAttestation) String() string { return proto.CompactTextString(m) }
func (*NoiseKeyAttestation) ProtoMessage()    {}
func (*NoiseKeyAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_14d195bf72570c49, []int{1}
}
func (m *NoiseKeyAttestation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoiseKeyAttestation.Unmarshal(m, b)
}
func (m *NoiseKeyAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoiseKeyAttestation.Marshal(b, m, deterministic)
}
func (m *NoiseKeyAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoiseKeyAttestation.Merge(m, src)
}
func (m *NoiseKeyAttestation) XXX_Size() int {
	return xxx_messageInfo_NoiseKeyAttestation.Size(m)
}
func (m *NoiseKeyAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_NoiseKeyAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_NoiseKeyAttestation proto.InternalMessageInfo

func (m *NoiseKeyAttestation) GetNodeCertchain() []byte {
	if m != nil {
		return m.NodeCertchain
	}
	return nil
}

func (m *NoiseKeyAttestation) GetNoiseProto() NoiseProtocol {
	if m != nil {
		return m.NoiseProto
	}
	return NoiseProtocol_NOISE_UNSET
}

func (m *NoiseKeyAttestation) GetNoisePublicKey() []byte {
	if m != nil {
		return m.NoisePublicKey
	}
	return nil
}

func (m *NoiseKeyAttestation) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *NoiseKeyAttestation) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// NoiseSessionAttestation is a structure that shows the given Noise session
// handshake hash is in use by a specific node id. The handshake hash is signed
// by the leaf key of the node's cert chain, where the node's cert chain is
// validated to belong to the given node id.
type NoiseSessionAttestation struct {
	NodeCertchain      []byte `protobuf:"bytes,2,opt,name=node_certchain,json=nodeCertchain,proto3" json:"node_certchain,omitempty"`
	NoiseHandshakeHash []byte `protobuf:"bytes,3,opt,name=noise_handshake_hash,json=noiseHandshakeHash,proto3" json:"noise_handshake_hash,omitempty"`
	Signature          []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// signers should fill this in, validators should ignore this field
	// and just use the node id computed by the cert chain.
	DeprecatedNodeId     NodeID   `protobuf:"bytes,1,opt,name=deprecated_node_id,json=deprecatedNodeId,proto3,customtype=NodeID" json:"deprecated_node_id"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NoiseSessionAttestation) Reset()         { *m = NoiseSessionAttestation{} }
func (m *NoiseSessionAttestation) String() string { return proto.CompactTextString(m) }
func (*NoiseSessionAttestation) ProtoMessage()    {}
func (*NoiseSessionAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_14d195bf72570c49, []int{2}
}
func (m *NoiseSessionAttestation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NoiseSessionAttestation.Unmarshal(m, b)
}
func (m *NoiseSessionAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NoiseSessionAttestation.Marshal(b, m, deterministic)
}
func (m *NoiseSessionAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NoiseSessionAttestation.Merge(m, src)
}
func (m *NoiseSessionAttestation) XXX_Size() int {
	return xxx_messageInfo_NoiseSessionAttestation.Size(m)
}
func (m *NoiseSessionAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_NoiseSessionAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_NoiseSessionAttestation proto.InternalMessageInfo

func (m *NoiseSessionAttestation) GetNodeCertchain() []byte {
	if m != nil {
		return m.NodeCertchain
	}
	return nil
}

func (m *NoiseSessionAttestation) GetNoiseHandshakeHash() []byte {
	if m != nil {
		return m.NoiseHandshakeHash
	}
	return nil
}

func (m *NoiseSessionAttestation) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func init() {
	proto.RegisterEnum("noise.NoiseProtocol", NoiseProtocol_name, NoiseProtocol_value)
	proto.RegisterType((*NoiseInfo)(nil), "noise.NoiseInfo")
	proto.RegisterType((*NoiseKeyAttestation)(nil), "noise.NoiseKeyAttestation")
	proto.RegisterType((*NoiseSessionAttestation)(nil), "noise.NoiseSessionAttestation")
}

func init() { proto.RegisterFile("noise.proto", fileDescriptor_14d195bf72570c49) }

var fileDescriptor_14d195bf72570c49 = []byte{
	// 457 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x51, 0xc1, 0x6e, 0xda, 0x40,
	0x14, 0x8c, 0x69, 0x40, 0xe5, 0x41, 0x28, 0xda, 0x22, 0x15, 0xa1, 0x46, 0x10, 0xa4, 0x48, 0x28,
	0x07, 0xd3, 0x52, 0x71, 0xa8, 0xd4, 0x8b, 0x4d, 0x51, 0x41, 0xa4, 0x24, 0x32, 0x69, 0xa5, 0xf6,
	0x62, 0x19, 0x7b, 0x63, 0x6f, 0x02, 0xfb, 0x2c, 0xef, 0x72, 0xe0, 0x2f, 0xfa, 0x43, 0xbd, 0xf7,
	0xd4, 0x0f, 0xe8, 0x21, 0xfd, 0x95, 0xca, 0xbb, 0xd8, 0x88, 0x1e, 0x7a, 0xa8, 0x72, 0xf3, 0x9b,
	0x37, 0xf3, 0x3c, 0x33, 0x0b, 0x15, 0x8e, 0x4c, 0x50, 0x33, 0x4e, 0x50, 0x22, 0x29, 0xaa, 0xa1,
	0x05, 0x21, 0x86, 0xa8, 0xa1, 0x56, 0x3b, 0x44, 0x0c, 0x57, 0xb4, 0xaf, 0xa6, 0xe5, 0xe6, 0xb6,
	0x2f, 0xd9, 0x9a, 0x0a, 0xe9, 0xad, 0x63, 0x4d, 0xe8, 0x7e, 0x86, 0xf2, 0x3c, 0x55, 0x4d, 0xf9,
	0x2d, 0x92, 0x0b, 0x28, 0x2a, 0xb4, 0x69, 0x74, 0x8c, 0x5e, 0x6d, 0xd0, 0x30, 0xf5, 0x75, 0x45,
	0xb8, 0x4e, 0x17, 0x3e, 0xae, 0x1c, 0x4d, 0x21, 0xa7, 0x00, 0xf1, 0x66, 0xb9, 0x62, 0xbe, 0x7b,
	0x4f, 0xb7, 0xcd, 0x42, 0xc7, 0xe8, 0x55, 0x9d, 0xb2, 0x46, 0x66, 0x74, 0xdb, 0xfd, 0x5e, 0x80,
	0xe7, 0x4a, 0x37, 0xa3, 0x5b, 0x4b, 0xca, 0xf4, 0x9f, 0x92, 0x21, 0x27, 0xe7, 0x50, 0xe3, 0x18,
	0x50, 0xd7, 0xa7, 0x89, 0xf4, 0x23, 0x8f, 0xf1, 0x9d, 0xf4, 0x24, 0x45, 0x47, 0x19, 0x48, 0x86,
	0xbb, 0x64, 0xae, 0xf6, 0xf3, 0xe4, 0x1f, 0x7e, 0x80, 0xe7, 0x23, 0xe9, 0x41, 0x7d, 0x27, 0xdb,
	0x5b, 0x3b, 0x56, 0xf7, 0x6b, 0x9a, 0x95, 0xf9, 0x23, 0x36, 0x94, 0xf3, 0x2a, 0x9a, 0xc5, 0x8e,
	0xd1, 0xab, 0x0c, 0x5a, 0xa6, 0x2e, 0xcb, 0xcc, 0xca, 0x32, 0x6f, 0x32, 0x86, 0xfd, 0xf4, 0xc7,
	0x43, 0xfb, 0xe8, 0xdb, 0xef, 0xb6, 0xe1, 0xec, 0x65, 0xe4, 0x25, 0x94, 0x05, 0x0b, 0xb9, 0x27,
	0x37, 0x09, 0x6d, 0x96, 0x74, 0x03, 0x39, 0x40, 0xde, 0x01, 0x09, 0x68, 0x9c, 0x50, 0xdf, 0x93,
	0x34, 0x70, 0x55, 0x68, 0x16, 0xa8, 0x66, 0xab, 0x76, 0x2d, 0x3d, 0xf7, 0xeb, 0xa1, 0x5d, 0x9a,
	0x63, 0x40, 0xa7, 0xef, 0x9d, 0xfa, 0x9e, 0xa9, 0x90, 0xa0, 0xfb, 0xd3, 0x80, 0x17, 0x2a, 0xe7,
	0x82, 0x0a, 0xc1, 0x90, 0xff, 0x47, 0x87, 0xaf, 0xa0, 0xa1, 0xcb, 0x88, 0x3c, 0x1e, 0x88, 0xc8,
	0xbb, 0x4f, 0xbf, 0x44, 0xa4, 0xca, 0xac, 0x3a, 0x44, 0xed, 0x26, 0xd9, 0x6a, 0xe2, 0x89, 0xe8,
	0x30, 0xd0, 0xf1, 0xa3, 0x06, 0xba, 0xb8, 0x83, 0x93, 0x83, 0x77, 0x23, 0xcf, 0xa0, 0x32, 0xbf,
	0x9a, 0x2e, 0xc6, 0xee, 0xa7, 0xf9, 0x62, 0x7c, 0x53, 0x3f, 0x22, 0xe7, 0x70, 0xa6, 0x81, 0xe9,
	0xcc, 0x1d, 0x0c, 0x87, 0xaf, 0xdf, 0xba, 0xa3, 0x89, 0x35, 0x9a, 0x58, 0xd7, 0x57, 0x97, 0x5f,
	0x5c, 0xfb, 0xd2, 0x9a, 0x8d, 0x07, 0x76, 0xdd, 0x20, 0x67, 0x70, 0xfa, 0x17, 0xcd, 0x1a, 0x2f,
	0x3e, 0x8c, 0x3e, 0xe6, 0x94, 0x82, 0xdd, 0xf8, 0x4a, 0x84, 0xc4, 0xe4, 0xce, 0x64, 0xd8, 0xf7,
	0x71, 0xbd, 0x46, 0xde, 0x8f, 0x97, 0xcb, 0x92, 0x7a, 0xd7, 0x37, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x7b, 0xae, 0xfe, 0x54, 0x34, 0x03, 0x00, 0x00,
}
